" opt into Vim 8’s new defaults
" see `:help defaults.vim`
unlet! skip_defaults_vim
if filereadable($VIMRUNTIME . '/defaults.vim')
  source $VIMRUNTIME/defaults.vim
endif

" Personal settings from pre-8
"filetype plugin indent on
"set ruler
"set showcmd
"set wildmenu
"set incsearch

" syntax highlighting, keep existing color settings
syntax enable 

" Nobody really needs modelines, especially with security issue
set modelines=0

" Don't fiddle with tabstop, just customize shiftwidth/softtabs
set shiftwidth=2
set softtabstop=2
set expandtab

" Sanity settings
set encoding=utf-8
set scrolloff=3
set autoindent
set showmode
set hidden
set wildmode=longest:full,full
set visualbell
set ttyfast
set backspace=indent,eol,start
set laststatus=2
" set relativenumber " requires Vim 7.3!
" set number " requires Vim 7.4!

" FIXME what about openbsd
"set shell=bash

" Disable cursor blinking
set gcr=a:blinkon0

" Don't show these filetypes in wildmenu
set wildignore=*.dll,*.o,*.pyc,*.bak,*.exe,*.jpg,*.jpeg,*.png,*.gif,*$py.class,*.class

" Use case-sensitive search if one-or-more uppercase chars
set ignorecase

" 'ignorecase' does not play nicely with completion
" (requires modern Vim!)
" FIXME seems to confuse Unite's completion in subbuffer, like <leader>e ?
"set infercase
"set smartcase

" Apply substitutions globally on lines (i.e., always assume /foo/bar/g)
set gdefault

" Highlite search results incrementally
set showmatch
set hlsearch

" Line wrapping
set wrap
" requires Vim 8+
set breakindent " indent wrapped lines, by...
set breakindentopt=shift:4,sbr " indenting them another level and showing 'showbreak' char
" see .gvimrc for showbreak and listchars
"set showbreak=↪
" with breakindent+relativenumber, display line movements unless preceded by a count
" (and save movements larger than 5 lines to the jumplist)
" TODO not sure if these are useful, and if they're causing slowdown
nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" Allow 'gq', automatically insert comment leader in Insert, recognize list numbers
set formatoptions=qrn1
"set colorcolumn=100 " visual warning if longer than 100 chars in line

" optimization: only syntax highlight the first 200 characters of each line
set synmaxcol=200

" Show invisible characters(tab, EOL)
set list

" Don't warn about files changing out from under us
set autoread

" Default spelling is US English
set spelllang=en_us

" Key mappings
let mapleader = "\<Space>"

" Change default regex to use \v
nnoremap / /\v
vnoremap / /\v

" Clear out search results
nnoremap <leader>, :noh<cr>

" Make ; do the same thing as :
nnoremap ; :


if has('macunix')
  " Disable middle mouse to avoid pasting problems on OSX
  map <MiddleMouse> <Nop>
  imap <MiddleMouse> <Nop>
end

" strip all trailing whitespace in the current file
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>
" use jj to exit insert mode
inoremap jj <ESC>
" Window-splitting helpers
" Split vertically with <leader>w
nnoremap <leader>w <C-w>v<C-w>l
" Split horizontally with <leader>v
nnoremap <leader>v <C-w>s<C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Default augroup for autocmds defined in vimrc
augroup vimrc
  autocmd!
augroup end

" force detection of *.md to Markdown, not modula-2
autocmd vimrc BufNewFile,BufReadPost *.md set filetype=markdown

" fold tags with ,ft
"nnoremap <leader>ft Vatzf

" Reselect just-pasted text with ,v
"nnoremap <leader>v V`]


" Autosave on losing focus
autocmd vimrc FocusLost * :wa

" SWP files and friends
" Write undo/swap files to a vim-specific temp dir
set backupdir=$HOME/.vtemp//
set directory=~/.vtemp//,/tmp
set undodir=~/.vtemp//
set viminfo+=n~/.vtemp/viminfo
" Skip /tmp and /private since changing anything there needs edit-in-place
set backupskip=/tmp/*,/private/tmp/*
" Automatically recover+delete swap files if reopening after a crash
augroup vimrc AutomaticSwapRecoveryAndDelete
    autocmd SwapExists * :let v:swapchoice = 'r' | let b:swapname = v:swapname
    autocmd BufWinEnter * :if exists("b:swapname") | call delete(b:swapname) | unlet b:swapname | endif
augroup end

" automatically equalize splits on resize
autocmd vimrc VimResized * wincmd =


" kill buffer without closing split
"command Bd bp\|bd \#

" TRIAL
" from https://github.com/garybernhardt/dotfiles/blob/master/.vimrc
" THis is a slightly smarter tab-complete. It moves backwards in the menu to
" avoid trickery with sending C-N after a Tab
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<Tab>"
    else
        return "\<C-P>"
    endif
endfunction
inoremap <expr> <Tab> InsertTabWrapper()
inoremap <S-Tab> <C-N>


" FIXME because these are called from vimrc, they don't seem to work if moved
" to an autoload script
" http://vim.wikia.com/wiki/Toggle_to_open_or_close_the_quickfix_window
function! GetBufferList() abort
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx) abort
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location list is empty"
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

nmap <silent> <leader>l :call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>q :call ToggleList("Quickfix List", 'c')<CR>

packadd! vim-lexical
" Can't define these in after/ftplugin as they are plugin-specific
augroup lexical
  autocmd!
  autocmd FileType markdown,mkd call lexical#init()
  autocmd FileType textile call lexical#init()
  autocmd FileType text call lexical#init({ 'spell': 0 })
  autocmd FileType vimwiki call lexical#init({ 'spell': 0 })
augroup END

" TODO move+load developer.vim to/from plugin/

" courtesy of steve losh
nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
